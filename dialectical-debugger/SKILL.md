---
name: dialectical-debugger
description: 代码修复，系统调试
---

---
name: dialectical-debugger
description: 基于唯物辩证法的bug修复和系统调试工具。使用辩证思维分析代码中的矛盾运动，识别根本问题，提供系统化的调试流程和解决方案。
triggers: ["@fix", "debug", "修bug", "报错", "exception", "error"]
---

# 辩证法调试器 (Dialectical Debugger)

## 核心哲学

### 1. 物质决定意识 (Context is King)
- 拒绝“银弹”调试方法。一切调试策略必须基于系统的具体物质条件（代码结构、运行环境、数据状态）。
- 没有绝对的“正确调试方法”，只有“在当前历史阶段最适合的调试方法”。

### 2. 对立统一规律 (Trade-off Analysis)
- 调试的本质是管理矛盾（局部vs全局，表面现象vs根本原因，时间成本vs彻底性）。
- 在行动前，必须识别当前的**主要矛盾**，并为了解决主要矛盾而果断牺牲次要矛盾。

### 3. 质量互变规律 (Scalability & Evolution)
- 预见量变引起的质变。当前的小问题可能是未来系统崩溃的前兆，必须分析问题的影响范围和演变趋势。
- 识别临界点（The Tipping Point），在过度调试（浪费时间）和调试不足（遗留问题）之间找到平衡的“度”。

### 4. 否定之否定 (Critical Refinement)
- 初次诊断的问题往往包含片面性。必须通过自我批判（验证假设、寻找反例、检查边缘情况）来“扬弃”初步结论，达到更高层级的正确性。

## 调试流程

### 阶段1: 唯物主义来源批判 (现象观察与数据收集)

**核心任务：** 收集客观证据，拒绝主观臆断

1. **复现问题**
   - 记录精确的复现步骤
   - 收集问题发生时的系统状态（日志、堆栈跟踪、环境变量）
   - 确定问题的边界条件（何时出现？何时不出现？）

2. **收集上下文**
   - 代码历史（最近的变更、相关的提交）
   - 系统架构（组件依赖、数据流）
   - 运行环境（硬件、操作系统、依赖版本）

3. **建立假设**
   - 基于客观证据提出可验证的假设
   - 记录所有可能的假设，不要过早排除任何可能性

### 阶段2: 矛盾分析与方案决断 (根本原因定位)

**核心任务：** 识别主要矛盾，定位根本原因

1. **分析矛盾运动**
   - 代码中的静态结构与动态执行之间的矛盾
   - 预期行为与实际行为之间的矛盾
   - 局部组件与全局系统之间的矛盾

2. **识别主要矛盾**
   - 哪个矛盾是导致问题的根本原因？
   - 哪些矛盾是次要的、可以暂时忽略的？

3. **验证假设**
   - 使用调试工具（断点、日志、性能分析）验证假设
   - 设计实验来测试不同的假设
   - 排除不可能的假设，聚焦于最可能的根本原因

### 阶段3: 否定性测试与演进预判 (解决方案设计)

**核心任务：** 设计健壮的解决方案，预见未来的演变

1. **设计解决方案**
   - 基于根本原因设计针对性的修复方案
   - 考虑解决方案对系统其他部分的影响
   - 评估解决方案的优缺点（权衡分析）

2. **否定性测试**
   - 攻击你的解决方案：它在什么情况下会失效？
   - 考虑边界情况、异常输入、并发条件
   - 模拟未来可能的变化（数据增长、流量增加）

3. **演进预判**
   - 这个修复会如何影响系统的未来演变？
   - 是否需要预留扩展接口？
   - 是否会引入新的矛盾？

### 阶段4: 实践检验真理 (修复实施与验证)

**核心任务：** 实施修复，验证有效性

1. **实施修复**
   - 编写符合系统风格的代码
   - 添加必要的注释，解释“为什么这么做”
   - 确保修复的可测试性

2. **验证修复**
   - 使用原问题的复现步骤验证修复效果
   - 运行相关的单元测试和集成测试
   - 进行回归测试，确保没有引入新问题

3. **文档化**
   - 记录问题的根本原因
   - 记录修复方案和决策过程
   - 记录验证结果和测试用例

## 使用指南

### 调试示例

**问题描述：** 系统在处理大量数据时崩溃

**阶段1: 唯物主义来源批判**
- 复现步骤：当数据量超过10,000条时，系统崩溃
- 收集上下文：查看日志发现内存溢出错误
- 建立假设：可能是内存泄漏或算法效率问题

**阶段2: 矛盾分析与方案决断**
- 分析矛盾：静态代码看起来正常，但动态执行时内存持续增长
- 识别主要矛盾：算法的时间复杂度为O(n²)，随着数据量增加，内存使用呈平方增长
- 验证假设：使用内存分析工具确认内存泄漏，使用性能分析工具确认算法效率问题

**阶段3: 否定性测试与演进预判**
- 设计解决方案：将算法优化为O(n log n)，添加内存释放机制
- 否定性测试：测试边界情况（空数据、重复数据、极大数据量）
- 演进预判：考虑未来数据量增长10倍的情况，预留引入分布式处理的接口

**阶段4: 实践检验真理**
- 实施修复：优化算法，添加内存管理代码
- 验证修复：使用100,000条数据测试，系统稳定运行
- 文档化：记录修复过程和测试结果

### 调试工具推荐

1. **代码分析工具**：静态代码分析、动态代码分析
2. **性能分析工具**：CPU分析器、内存分析器
3. **日志管理工具**：集中式日志系统、日志查询工具
4. **测试工具**：单元测试框架、集成测试框架、压力测试工具

## 注意事项

1. **拒绝机会主义调试**：不要只修复表面现象，必须找到根本原因
2. **拒绝教条主义调试**：不要机械地遵循固定流程，必须根据具体情况灵活调整
3. **重视矛盾运动**：代码是动态的，问题可能是多个因素相互作用的结果
4. **预见未来演变**：修复问题时必须考虑系统的长期演进

## 局限与演进

**当前局限：**
- 依赖调试人员的辩证思维能力
- 对于复杂系统，需要较长时间的分析
- 对于分布式系统，跨节点的矛盾分析难度较大

**未来演进方向：**
- 结合AI辅助分析，自动识别潜在的矛盾点
- 开发可视化工具，展示系统中的矛盾运动
- 建立调试知识库，积累不同场景下的调试经验

# 调试模板

## 问题报告

| 字段 | 内容 |
|------|------|
| 问题描述 | 简洁明了的问题描述 |
| 复现步骤 | 精确的复现步骤 |
| 预期行为 | 预期的系统行为 |
| 实际行为 | 实际的系统行为 |
| 环境信息 | 运行环境、依赖版本、配置信息 |
| 日志信息 | 相关的日志片段、错误信息 |

## 分析记录

| 阶段 | 内容 |
|------|------|
| 收集的证据 | 客观数据、日志、堆栈跟踪 |
| 提出的假设 | 可能的根本原因假设 |
| 验证方法 | 用于验证假设的方法和工具 |
| 验证结果 | 假设验证的结果 |
| 根本原因 | 确定的根本原因 |

## 修复方案

| 字段 | 内容 |
|------|------|
| 修复策略 | 修复的整体策略 |
| 具体措施 | 详细的修复步骤 |
| 权衡分析 | 修复方案的优缺点分析 |
| 风险评估 | 修复可能带来的风险 |
| 测试计划 | 验证修复的测试计划 |

## 验证结果

| 字段 | 内容 |
|------|------|
| 测试用例 | 执行的测试用例 |
| 测试结果 | 测试的结果 |
| 回归测试 | 回归测试的结果 |
| 性能影响 | 修复对性能的影响 |

# 结论

辩证法调试器不是一个具体的工具，而是一种思维方式。它要求调试人员用辩证的眼光看待系统，分析系统中的矛盾运动，识别根本原因，设计健壮的解决方案。通过遵循这个流程，你可以更有效地修复bug，提高系统的可靠性和可维护性。